
# 本项目说明

本项目是本人查阅资料与书籍，模拟实现GZIP压缩算法。本项目还没有实现自动识别文件类型，自动压缩，需要人手动的将文件名在程序中进行更改。本项目只是一个小项目，以后会一直维护此项目,第一个文件夹是项目文件，第二个是在实现时完成的次品。

## GZIP压缩简介

        gzip是若干种文件压缩程序的简称，通常指GNU计划的实现，此处的gzip代表GNU zip。也经常用来表示gzip这种文件格式。软件的作者是Jean-loup Gailly和Mark Adler。在1992年10月31日第一次公开发布，版本号0.1，1993年2月，发布了1.0版本。
        gzip的基础是DEFLATE，DEFLATE是LZ77与哈夫曼编码的一个组合体。 gzip 对于要压缩的文件，首先使用LZ77算法的一个变种进行压缩，对得到的结果再使用Huffman编码的方法（实际上gzip根据情况，选择使用静态Huffman编码或者动态Huffman编码，本文中只介绍静态编码）进行压缩。所以明白了LZ77算法和Huffman编码的压缩原理，也就明白了gzip的压缩原理。我们来对LZ77算法和Huffman编码做一个简单介绍。

## 基于Hhuffman树的压缩算法原理

        这个算法的原理就是对字符进行再编码。 我们把文件中一定位长的值看作是符号，比如把8位长的256的值，也就是字节的256种值看作是符号。我们根据这些符号在文件中出现的频率，对这些符号重新编码。对于出现次数非常多的，我们用较少的位来表示，对于出现次数非常少的，我们用较多的位来表示。这样一来，文件的一些部分位数变少了，一些部分位数变多了，由于变小的部分比变大的部分多，所以整个文件的大小还是会减小，所以文件得到了压缩。整体思路

#### 压缩：

1. 先读取整个文件，得到每个字符的出现次数
2. 根据出现的次数，建立huffman树
3. 根据huffman树得到huffman编码
4. 重新读取文件，用字符对应的huffman编码替换字符，输出到压缩文件中
5. 由于还需要进行解压缩，因此，应该将对应的字符信息、原文件后缀等也写入压缩文件中，这里是将这些信息当作头信息，写入压缩文件的开始。

#### 解压缩：

1. 读取压缩文件头部信息，获取字符信息，还原huffman树
2. 开始读取数据，根据huffman树，将huffman编码还原为字符

## 基于LZ77的压缩算法

### 原理

        LZ77算法是由 Lempel-Ziv 在1977发明的，也是GBA内置的压缩算法。它是一种基于字典的、“滑动窗”的无损压缩算法，广泛应用于通信、计算机文件存档等方面。
        LZ77算法通过使用编码器或者解码器中已经出现过的相应匹配数据信息替换当前数据从而实现压缩功能。这个匹配信息使用称为长度-距离对的一对数据进行编码，它等同于“每个给定长度个字符都等于后面特定距离字符位置上的未压缩数据流。”（“距离”有时也称作“偏移”。）整体思路

#### 压缩

1. 我们从文件中读取数据，并将其存储在一段连续的空间内，空间也被称为窗口，空间的大小一般为64K(不固定)。
2. 挨个遍历这片空间，每当遇见一个字符，我们都向前查找一段距离。如果在这个字符的前面，找到和它相同的字符，那么，开始向后匹配，看从当前位置开始能匹配到多少相同的字符，如果匹配到的字符数大于<距离，长度>对所占的空间，就说明能够压缩数据。
3. 从找到的位置再往前找，看是否有相同的字符，如果有，那么重复2 ，3.一直到找不多，或者超出查找的范围为止。这样，就能得到一个最长匹配串，用对应的<长度，距离>对，替换字符，即可达到压缩的目的。
4. 由于原数据和压缩数据是混合存入压缩文件的，因此，为了方便解压缩，应该再存入一段数据，进行标记，哪个字节是原数据，哪个字节是距离长度对。

#### 解压缩

1. 先从压缩文件中读取关于原文件的相关信息。
2. 读取压缩文件的数据部分，同时，读取标记部分，如果标记是原数据，就直接写入，如果是<长度，距离>对，就往前找，进行匹配，然后向解压文件中写入。
3. 重复2 直到解压完成。





