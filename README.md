
# 本项目说明

本项目是本人查阅资料与书籍，模拟实现GZIP压缩算法。本项目还没有实现自动识别文件类型，自动压缩，需要人手动的将文件名在程序中进行更改。本项目只是一个小项目，以后会一直维护此项目,第一个文件夹是项目文件，第二个是在实现时完成的次品。

## GZIP压缩简介

        gzip是若干种文件压缩程序的简称，通常指GNU计划的实现，此处的gzip代表GNU zip。也经常用来表示gzip这种文件格式。软件的作者是Jean-loup Gailly和Mark Adler。在1992年10月31日第一次公开发布，版本号0.1，1993年2月，发布了1.0版本。
        gzip的基础是DEFLATE，DEFLATE是LZ77与哈夫曼编码的一个组合体。 gzip 对于要压缩的文件，首先使用LZ77算法的一个变种进行压缩，对得到的结果再使用Huffman编码的方法（实际上gzip根据情况，选择使用静态Huffman编码或者动态Huffman编码，本文中只介绍静态编码）进行压缩。所以明白了LZ77算法和Huffman编码的压缩原理，也就明白了gzip的压缩原理。我们来对LZ77算法和Huffman编码做一个简单介绍。

## 基于Hhuffman树的压缩算法原理

        这个算法的原理就是对字符进行再编码。 我们把文件中一定位长的值看作是符号，比如把8位长的256的值，也就是字节的256种值看作是符号。我们根据这些符号在文件中出现的频率，对这些符号重新编码。对于出现次数非常多的，我们用较少的位来表示，对于出现次数非常少的，我们用较多的位来表示。这样一来，文件的一些部分位数变少了，一些部分位数变多了，由于变小的部分比变大的部分多，所以整个文件的大小还是会减小，所以文件得到了压缩。整体思路

#### 压缩：

1. 先读取整个文件，得到每个字符的出现次数
2. 根据出现的次数，建立huffman树
3. 根据huffman树得到huffman编码
4. 重新读取文件，用字符对应的huffman编码替换字符，输出到压缩文件中
5. 由于还需要进行解压缩，因此，应该将对应的字符信息、原文件后缀等也写入压缩文件中，这里是将这些信息当作头信息，写入压缩文件的开始。

#### 解压缩：

1. 读取压缩文件头部信息，获取字符信息，还原huffman树
2. 开始读取数据，根据huffman树，将huffman编码还原为字符

## 基于LZ77的压缩算法

### 原理

        LZ77算法是由 Lempel-Ziv 在1977发明的，也是GBA内置的压缩算法。它是一种基于字典的、“滑动窗”的无损压缩算法，广泛应用于通信、计算机文件存档等方面。
        LZ77算法通过使用编码器或者解码器中已经出现过的相应匹配数据信息替换当前数据从而实现压缩功能。这个匹配信息使用称为长度-距离对的一对数据进行编码，它等同于“每个给定长度个字符都等于后面特定距离字符位置上的未压缩数据流。”（“距离”有时也称作“偏移”。）整体思路

#### 压缩

用<长度,距离>对替换相同的匹配串，并作标记。在另外一个文件中用0表示原字符，1表示长度距离对。

1. 从文件中读取一部分数据，并将其存储在一段来连续的空间内，空间也被称为窗口，空间大小为64K，将整个窗口分为左窗与右窗，逻辑上分为查找缓冲区与先行缓冲区。
2. 查找缓冲区存放的是已经压缩过的数据，先行缓冲区存放的是未进行匹配的数据，先行缓冲区第一个字节定义为start也就是压缩的起始位置
3. 因为我们的<长度，距离>对中，长度占一个字节范围为[0,255]，所以匹配的最大长度MAX_MATCH为[3,258]，因为小于MIN_MATCH--3个字节不进行匹配，也就是小于<长度，距离>对所占空间的字符串不进行匹配
4. 如果文件大于64K，大于滑动窗口的空间，我们就要对移动滑动窗口，当先行缓冲区剩余字节数为MIN_LOOKAHEAD = MAX_MATCH+MIN_MATCH+1。也就是保证本次匹配可以达到最大值同时还可以进行下一次匹配时，我们就对滑动窗口进行移动
   - 怎么移动？
   - 1. 将WSIZE2窗口中的数据导入到WSIZE1窗口中，start-=WSIZE；
     2. 从待压缩文件中再重新读取一个WISIZE的数据到WSIZE2
     3. 更新哈希表
5. 查找最长的匹配串的时候需要用到哈希表。我们在进行压缩时每遇到一个字符计算其哈希地址将它插入到哈希表的右窗，我们每找到一个匹配串，我们就计算下它的哈希地址，把它保存到哈希表的右窗的位置，head[hashAddr] = 该匹配串的头部信息。如果出现冲突，说明找到匹配，此时保存原来哈希表中此地址的值，也就是字符的位置，然后将其保存到左窗中的此时找到匹配字符的下标处，比如遇到两个相同的字符a，一次a在待压缩文件中的下标是5，第二个字符a的下标在待压缩文件中下标是10。比如a的哈希地址是3，那么遇到第一次a，我在右窗中3的位置保存5，遇到第二个a，我在左窗中10的位置保存5。这样就形成一条链，沿着这条链就可以找到最远的匹配了。所以左窗中prev的作用其实保存了最远的匹配，而右窗中head的作用保存最近一次的匹配。
6. 为了防止越界要在运算时&上掩码。哈希桶的大小设置为2的15次方。除此之外，还有可能某条链会构成环，所以我们要设置一个最大匹配次数255。
7. 解压缩时，读取压缩文件，用该字节对应的标记还原即可。


#### 解压缩

1. 先从压缩文件中读取关于原文件的相关信息。
2. 读取压缩文件的数据部分，同时，读取标记部分，如果标记是原数据，就直接写入，如果是<长度，距离>对，就往前找，进行匹配，然后向解压文件中写入。
3. 重复2 直到解压完成。





